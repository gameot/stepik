**Тестовое задание на позицию Backend разработчик в Stepik**   
**Стек:** Django1.11, Python3.7.  
**Срок:** 3–5 дней.  
**Лимит кода:** ≤ 350 LoC продакшен‑кода (не учитывая тесты и миграции).  
>Если информации не хватает, **сделайте разумные предположения**. Коротко зафиксируйте их в задаче. Мы оцениваем ваш ход мыслей и умение определять контекст

---

**Что мы ожидаем** 

* Ссылка на публичный репозиторий с решением **одной задачи** из списка.  
  * **Документ с описанием технического дизайна**:  
    * Какие предположения вы сделали и почему.  
    * Что может пойти не так при масштабе **100×** от текущего?  
    * 3 метрики, которые вы бы включили в первый релиз (конкретно: counter names, alert thresholds).  
    * Один абзац: «Если это сломается в 3 утра, куда смотреть, чтобы понять, что произошло».  
  * **Короткий список «следующих шагов»** (≤ 10 пунктов): что еще добавить перед реальным продакшеном?

---

**Выберите одну задачу**   
**A) Payment Webhook Ingest (idempotent \+ fast ACK)**   
**Сценарий:** Партнёр отправляет платёжные события (charge.succeeded, refund.created, dispute.opened). События могут быть **duplicated** и приходить **out‑of‑order**.  
**Реализация:**

* POST /v1/webhooks/payment, который:  
  * Проверяет HMAC-SHA256‑заголовок, при несовпадении возвращает 401\.  
    * Сохраняет событие с дедупликацией в БД (provider\_event\_id).  
    * Ставит асинхронную обработку в очередь (Celery). **Ответ ≤ 200мс** на валидный запрос.  
  * Worker, который обрабатывает события идемпотентно:  
    * Для charge.succeeded помечает заказ оплаченным один раз (никогда дважды).  
    * Для refund.created создаёт запись возврата только один раз, даже при ретраях.  
    * На 429/5xx от downstream применяет экспоненциальный retry с верхней границей попыток.  
* **Критерии выполнения (должно быть показано в тестах):**  
  * Валидная подпись: 200; невалидная: 401\.  
  * Дубликат provider\_event\_id не вызывает побочных эффектов.  
  * Refund, пришедший раньше charge, обрабатывается детерминированно, т.е. всегда одним и тем же способом (объясните выбор).  
  * Необязательно: определите p95‑цели для запроса; укажите один‑два счётчика/alert, которые вы бы добавили.

----

***Ответы***

**Что нужно еще сделать:**
- вынести переменные, особенной связанные с безопасностью из settings в environment variables
- нужно подключить что-то типа FactoryBoy, чтобы было в тестах проще создавать объекты моделей
- не настроена админка

**Предположения**
- В поле event_id приходит уникальный ID для всех возможных провайдеров финансовых операций. Это сделано с целью ограничения разрабатываемого функционала.
- Для упрощения считаем, что к нам приходят всего 3 вида вебхука.
- У нас нет частичных возвратов и оплат. Приходят ровно суммы заказа.
- Рефанд может быть только после прихода подтверждения оплаты. Если придет раньше, то ждем подтверждения списания.
- Нет учета баланса пользователя, чтобы не вернуть пользователю лишнего.

**Что может пойти не так при масштабе **100×** от текущего?**
Здесь непонятен какой текущий масштаб. 
- может заваливать очередь если будет приходить много рефандов перед приходом оплаты или не будут отчечать сторонние сервисы.
- может начать проседать производительность MySQL
- можем начать неуспевать обрабатывать запросы django.

**3 метрики, которые вы бы включили в первый релиз (конкретно: counter names, alert thresholds).**
- время ответа на вебхук. Алерт если больше 5% запросов отвечают медленнее 200мсек
- среднее количество ретраев на таску. Алерт, если больше 2
- сколько тасок находится в очереди на обработку. На какой thresholds ставить алерт надо смотреть от обычной нагрузки

**Один абзац: «Если это сломается в 3 утра, куда смотреть, чтобы понять, что произошло». **
- смотреть логи на наличие ошибок
- смотреть метрики celery

**Короткий список «следующих шагов»**
- много упрощений, надо решить с ними вопрос
- нужно подумать что делать в случае если таска протухнет, например пришел рефанд, мы его не обработали так как ждем подтверждение списания, а оно не пришло.
- настроить логирование
- настроить метрики
- настроить оповещения

PS По-хорошему, надо было бы сначала порешать все возникающие вопросы бизнес логики, а потом писать код. 